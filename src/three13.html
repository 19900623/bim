<!DOCTYPE html>
<html lang="en">
<head>
	<title>BIM模型展示-测试工程</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<!-- TODO: 修改路径 -->
	<link rel="stylesheet" href="css/jquery.mobile-1.4.5.min.css">
	<!-- TODO: 修改路径 -->
	<link rel="stylesheet" href="css/jqm-override-13.css">
	<!-- TODO: 修改路径 -->
	<script src="js/jquery-1.11.3.min.js"></script>
	<!-- TODO: 修改路径 -->
	<script src="js/jquery.mobile-1.4.5.min.js"></script>
</head>

<body>

	<div id="blocker">
		<div id="instructions">
			<span style="font-size:40px">Click to Move Around</span>
			<br />
			(W, A, S, D = Move, SPACE = Jump, MOUSE = Look around)
		</div>
	</div>

	<!-- <div id="main-page" data-role="page">

	  <div data-role="panel" data-display="overlay" id="model_details_panel">
    	<ul data-role="listview" class="list-view-scroll" data-filter="true" id="model_details_panel_ul">
    	</ul>
    </div>

		<div role="main" class="ui-content" data-position="fixed">
		</div>

		<div class="center-wrapper" data-tap-toggle="false" data-role="footer" data-position="fixed">
   		<a id="reset_model_btn" class="ui-btn ui-icon-eye ui-btn-icon-notext ui-corner-all center-btn"></a>
		</div>
	</div> -->

	<!-- TODO: 修改路径 -->
	<script src="js/three.min.js"></script>
	<!-- TODO: 修改路径 -->
	<script src="js/PointerLockControls.js"></script>
	<script src="js/OrbitControls.js"></script>

	<script>
		// loader 
		// $(document).ready( function(){
		// 	$.mobile.loading( "show", {
  //           text: "模型载入中...",
  //           textVisible: true,
  //           theme: $.mobile.loader.prototype.options.theme,
  //           textonly: true,
  //           html: ""
  //   	});
		// });
	</script>

	<script>
		function computeNormalsAndFaces() {
      for(var i=0; i<scene.children.length; i++){
      	// obsolete?
      	if( scene.children[i].hasOwnProperty("geometry")){
        	scene.children[i].geometry.mergeVertices();
        	// scene.children[i].castShadow = true;
        	scene.children[i].geometry.computeFaceNormals();
        	targetList.push( scene.children[i] );
      	}
      	if( scene.children[i].children.length > 0 ){
        	for (var k=0; k<scene.children[i].children.length ; k++){
        		// yu: object3d has no geo...adding all children to targetlist for now
          	// if(scene.children[i].children[k].hasOwnProperty("geometry")){
          	if(scene.children[i].children[k].hasOwnProperty("userData") && 
          		!(Object.keys(scene.children[i].children[k].userData) === 0) ){
            	targetList.push(scene.children[i].children[k]);
          	}
        	}
      	}
    	}
    }
	</script>

	<script>
		function displayAttributes( obj ) {
      $("#model_details_panel_ul").empty();
      var detail_entry;

      var arr = Object.keys( obj );
      for (var i = 0, len = arr.length; i < len; i++) {
      	if ( obj[arr[i]] != undefined) {
        	if ( obj[arr[i]].indexOf('http') == 0) {
         		console.log("displayAttributes: index of http == 0");
       		} else {
         		detail_entry = document.createElement("li");
         		detail_entry.className = "wrap-text";
						detail_entry.innerHTML = arr[i] + ": " + obj[ arr[i] ];
						$("#model_details_panel_ul").append(detail_entry);
       		}
     		}
   		}
			$("#model_details_panel_ul").listview('refresh');
      $("#model_details_panel").panel("open");
 		}
	</script>

	<script>
		function clickHandler(event){
		  event.preventDefault();

		  selMaterial = new THREE.MeshBasicMaterial( { color: 'red', side: '2' });   //color for selected mesh element

		  // When clicking without selecting object, replace temp material for meshes and object3D
		  // Yu: may be obsolete
		  if(lastMeshMaterial!=-1)
		  {
		    //reset last material for last lastMeshID
		    for(var i = 0; i < targetList.length;i++)
		    {
		      if (targetList[i].id == lastMeshID)
		      {
		        targetList[i].material = lastMeshMaterial;
		      }
		    }
		  }

		  // TODO: to be optimized
		  if(lastObjectMaterial!=-1)
		  {
		    INTERSECTED.object.material = lastObjectMaterial;
		  }

		  // intersects http://stackoverflow.com/questions/33604515/how-to-find-intersect-with-object3d-in-three-js
		  raycaster.setFromCamera( mouse, camera );
			var intersects = raycaster.intersectObjects( scene.children, true );

		  if ( intersects.length > 0 ) {
		    var j =0;
		    while(j<intersects.length){
		      //FOR MESHES: // Yu: may be obsolete
		      if(!$.isEmptyObject(intersects[j].object.userData)){
		        console.log(intersects[j].object.userData);

		        if(lastMeshMaterial!=-1)
		        {
		          //reset last material for last lastMeshID
		          for(var i = 0; i < targetList.length;i++)
		          {
		            if (targetList[i].id == lastMeshID)
		            {
		              targetList[i].material = lastMeshMaterial;
		            }
		          }
		        }

		        //set lastMaterial
		        lastMeshMaterial = intersects[j].object.material;
		        //set lastMeshID
		        lastMeshID = intersects[j].object.id;
		        //apply SelMaterial
		        intersects[j].object.material = selMaterial;

		        displayAttributes( intersects[j].object.userData );
		        break;
		      }
		      // FOR OBJECT3D
		      // For rvtVa3C tag 2015.0.0.28 and later, seems exported json are mostly oject3d
		      if(!$.isEmptyObject(intersects[j].object.parent.userData)){
		        console.log(intersects[j].object.parent.userData);

		        if(lastObjectMaterial!=-1)
		        {
		          INTERSECTED.object.material = lastObjectMaterial;
		        }

		        //set lastMaterial
		        lastObjectMaterial = intersects[j].object.material;
		        //apply SelMaterial
		        intersects[j].object.material = selMaterial;
		        // yu: save intersected object
		        INTERSECTED = intersects[j];

		        displayAttributes( intersects[j].object.parent.userData );
		        break;
		      }
		      j++;
		    } // end of while
		  } else {
      	$("#model_details_panel_ul").empty();
      	$("#model_details_panel").panel("close");
		  }
		}
	</script>

	<script>

		// get pointer lock

		var blocker = document.getElementById( 'blocker' );
		var instructions = document.getElementById( 'instructions' );

		// http://www.html5rocks.com/en/tutorials/pointerlock/intro/

		var havePointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document;

		if ( havePointerLock ) {
			var element = document.body;

			var pointerlockchange = function ( event ) {
				if ( document.pointerLockElement === element || document.mozPointerLockElement === element || document.webkitPointerLockElement === element ) {

					controlsEnabled = true;
					controls.enabled = true;

					blocker.style.display = 'none';

				} else {
					controls.enabled = false;

					blocker.style.display = '-webkit-box';
					blocker.style.display = '-moz-box';
					blocker.style.display = 'box';

					instructions.style.display = '';

				}
			};

			var pointerlockerror = function ( event ) {
				instructions.style.display = '';

			};

			// Hook pointer lock state change events
			document.addEventListener( 'pointerlockchange', pointerlockchange, false );
			document.addEventListener( 'mozpointerlockchange', pointerlockchange, false );
			document.addEventListener( 'webkitpointerlockchange', pointerlockchange, false );

			document.addEventListener( 'pointerlockerror', pointerlockerror, false );
			document.addEventListener( 'mozpointerlockerror', pointerlockerror, false );
			document.addEventListener( 'webkitpointerlockerror', pointerlockerror, false );

			instructions.addEventListener( 'click', function ( event ) {
				instructions.style.display = 'none';

				// Ask the browser to lock the pointer
				element.requestPointerLock = element.requestPointerLock || element.mozRequestPointerLock || element.webkitRequestPointerLock;

				if ( /Firefox/i.test( navigator.userAgent ) ) {
					var fullscreenchange = function ( event ) {

						if ( document.fullscreenElement === element || document.mozFullscreenElement === element || document.mozFullScreenElement === element ) {

							document.removeEventListener( 'fullscreenchange', fullscreenchange );
							document.removeEventListener( 'mozfullscreenchange', fullscreenchange );

							element.requestPointerLock();
						}

					};

					document.addEventListener( 'fullscreenchange', fullscreenchange, false );
					document.addEventListener( 'mozfullscreenchange', fullscreenchange, false );

					element.requestFullscreen = element.requestFullscreen || element.mozRequestFullscreen || element.mozRequestFullScreen || element.webkitRequestFullscreen;

					element.requestFullscreen();

				} else {
					element.requestPointerLock();

				}
			}, false );

		} // if have pointer lock
		else {
			instructions.innerHTML = 'Your browser doesn\'t seem to support Pointer Lock API';

		}

	  // from three12

		var SCREEN_WIDTH = window.innerWidth;
		var SCREEN_HEIGHT = window.innerHeight;

		var container, stats;
		var camera, scene, renderer;
		var bbox, bboxCenter;
		var queryString;
		// Va3c...
		var lastMeshMaterial, lastMeshID, lastObjectMaterial, lastObjectID;
		var selMaterial;
		var targetList = [];

		// Intercect
		var raycaster;
		var mouse = new THREE.Vector2(), INTERSECTED;
		var lastHex;
		// Test
		var bboxLine;

		init();
		animate();

		var controlsEnabled = false;

		var moveForward = false;
		var moveBackward = false;
		var moveLeft = false;
		var moveRight = false;
		var canJump = false;
		// Custom
		var moveUp = false;
		var moveDown = false;

		var prevTime = performance.now();
		var velocity = new THREE.Vector3();

		function init() {

			lastMeshMaterial = -1;
  		lastMeshID = -1;
  		lastObjectMaterial = -1;
  		lastObjectID = -1;

			container = document.createElement( 'div' );
			$(".ui-content").append( container );

			// SCENE

			scene = new THREE.Scene();

			// CAMERA

			// camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 15000 );
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 5000 );
		  // camera.position.set( 250, 0, 250 );
		  scene.add(camera);

			// CONTROLS

			// controls = new THREE.OrbitControls( camera );
			controls = new THREE.PointerLockControls( camera );
			scene.add( controls.getObject() );
			// controls.maxPolarAngle = 0.9 * Math.PI / 2;
			// controls.enableZoom = false;

			var onKeyDown = function ( event ) {

				switch ( event.keyCode ) {

					case 38: // up
					case 87: // w
						moveForward = true;
						break;

					case 37: // left
					case 65: // a
						moveLeft = true; break;

					case 40: // down
					case 83: // s
						moveBackward = true;
						break;

					case 39: // right
					case 68: // d
						moveRight = true;
						break;

					case 32: // space
						// if ( canJump === true ) velocity.y += 350;
						// if ( canJump === true ) velocity.y += 100;
						// canJump = false;
						break;

					case 81: // q
						moveUp = true;
						console.log("q pressed...");
						break;

					case 69: // e
						moveDown = true;
						console.log("e pressed...");
						break;

				}
			};

			var onKeyUp = function ( event ) {

				switch( event.keyCode ) {

					case 38: // up
					case 87: // w
						moveForward = false;
						break;

					case 37: // left
					case 65: // a
						moveLeft = false;
						break;

					case 40: // down
					case 83: // s
						moveBackward = false;
						break;

					case 39: // right
					case 68: // d
						moveRight = false;
						break;

					case 81: // q
						moveUp = false;
						break;

					case 69: // e
						moveDown = false;
						break;	

				}
			};

			document.addEventListener( 'keydown', onKeyDown, false );
			document.addEventListener( 'keyup', onKeyUp, false );

			// Va3c
			raycaster = new THREE.Raycaster();

	    // reset btn

	  //   $("#reset_model_btn").on("click", function(event){
	  //   	controls.reset();
	  //   });

	  //   // model detail panel

			// $("#model_details_panel").on("panelopen", function(event, ui) {
			// 		controls.enabled = false;
			// 	});

			// $("#model_details_panel").on("panelclose", function(event, ui) {
			// 		controls.enabled = true;
			// 	});

			// RENDERER

			renderer = new THREE.WebGLRenderer( { alpha: 1, antialias: true } );
			// TODO: 背景色
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.setSize( SCREEN_WIDTH, SCREEN_HEIGHT );
			// container.appendChild( renderer.domElement );
			document.body.appendChild( renderer.domElement );

			// load model

			var manager = new THREE.LoadingManager();
			manager.onProgress = function ( item, loaded, total ) {
				console.log( item, loaded, total );
			};

			var onProgress = function ( xhr ) {
				if ( xhr.lengthComputable ) {
					var percentComplete = xhr.loaded / xhr.total * 100;
					console.log(Math.round(percentComplete, 2) + "%");
					// $(".ui-loader").html("<h1>模型载入中..." + Math.round(percentComplete, 2) + "%</h1>");
				}
			};

			var onError = function ( xhr ) {
			};

			var loader = new THREE.ObjectLoader(manager);

			// loader.load( 'hotel2.js', function ( object ) {
			loader.load( 'mesa.js', function ( object ) {

				scene.add(object);

				// a light 

				var ambientLight = new THREE.AmbientLight(0x332222);
				scene.add(ambientLight);

				// bbox = new THREE.Box3().setFromObject(object);
				// bboxCenter = new THREE.Vector3();
				// bboxCenter.subVectors(bbox.max, bbox.min);
				// bboxCenter.multiplyScalar(0.5);
				// bboxCenter.add(bbox.min);
				// bboxCenter.applyMatrix4(object.matrixWorld);

				// object.position.y -= bboxCenter.y;
				// object.position.x = -100;
				// object.position.x = 0;
				// object.position.x -= bboxCenter.x;
				// object.position.z = -100;
				// object.position.z = 0;
				// object.position.z -= bboxCenter.z;
				// controls.object.target = bboxCenter;

				// var depth = 1.3;
				// var objWidthZ = Math.abs(bbox.max.y - bbox.min.y) / 2;
				// var dist = bboxCenter.distanceTo(camera.position) - objWidthZ;
    //     var objHeight = Math.abs(bbox.max.y - bbox.min.y);

    //     var fov = 2 * Math.atan(objHeight * depth / ( 2 * dist )) * ( 180 / Math.PI );

    //     camera.fov = fov;
    //     camera.updateProjectionMatrix();

        // For testing Only
        bbox = new THREE.BoundingBoxHelper( object, 0xff0000 );
				bbox.update();
				// scene.add( bboxLine );

				object.position.x -= bbox.position.x;
				object.position.z -= bbox.position.z;

				// controls.getObject().position.y = 10;



				// 坑：不知道为什么灯光放在摄像定位前面就有问题？
				var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.5);
        // hemiLight.position.copy(bbox.box.max.multiplyScalar(2));
        hemiLight.position.copy(new THREE.Vector3(0, bbox.position.y * 3, 0));
        hemiLight.name = 'hemiLight';
        scene.add(hemiLight);

        var pointlight = new THREE.PointLight( 0xffffff, 0.1, 100 );
        camera.add(pointlight);

    		var directionalLight = new THREE.DirectionalLight(0xffffff, 0.6 );
        directionalLight.position.copy(new THREE.Vector3(1000, 1000, 1000));
        // scene.add(directionalLight);

        //call compute function
    		// computeNormalsAndFaces();

  			// document.addEventListener( 'dblclick', clickHandler, false );
  			// document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				// jqm loader
			  // $.mobile.loading( "hide" );

			}, onProgress, onError );

			window.addEventListener( 'resize', onWindowResize, false );
		}

		function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		function animate() {
			requestAnimationFrame( animate );
			// controls.update();

			if ( controlsEnabled ) {
				// raycaster.ray.origin.copy( controls.getObject().position );
				// raycaster.ray.origin.y -= 10;

				// var intersections = raycaster.intersectObjects( objects );

				// var isOnObject = intersections.length > 0;
				var isOnObject = true;

				var time = performance.now();
				var delta = ( time - prevTime ) / 1000;

				velocity.x -= velocity.x * 10.0 * delta;
				velocity.z -= velocity.z * 10.0 * delta;
				velocity.y -= velocity.y * 10.0 * delta;

				// velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

				if ( moveForward ) velocity.z -= 400.0 * delta;
				if ( moveBackward ) velocity.z += 400.0 * delta;

				if ( moveLeft ) velocity.x -= 400.0 * delta;
				if ( moveRight ) velocity.x += 400.0 * delta;

				if ( moveUp ) velocity.y -= 400.0 * delta;
				if ( moveDown ) velocity.y += 400.0 * delta;

				// if ( isOnObject === true ) {
				// 	velocity.y = Math.max( 0, velocity.y );

				// 	canJump = true;
				// }
				// canJump = true;

				controls.getObject().translateX( velocity.x * delta );
				controls.getObject().translateY( velocity.y * delta );
				controls.getObject().translateZ( velocity.z * delta );
				console.log(velocity.x + " " + velocity.y + " " + velocity.z);


				if ( controls.getObject().position.y < 0 ) {

					// velocity.y = 0;
					// controls.getObject().position.y = 10;
					// console.log("get object postion y...");

					// canJump = true;

				}

				prevTime = time;

			}

			renderer.render( scene, camera );

		}
	</script>

	<script>
		function onDocumentMouseMove( event ) {
			event.preventDefault();

			mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
			mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
		}
	</script>
</body>
</html>